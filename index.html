<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Foosball Timer</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            height: auto; /* Allow scrolling */
            margin: 0;
            background-color: #f0f0f0;
            padding: 20px;
        }
        #status {
            font-size: 24px;
            margin-bottom: 20px;
        }
        button {
            font-size: 18px;
            padding: 10px 20px;
            margin: 10px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
        #startBtn {
            background-color: #4CAF50;
            color: white;
        }
        #resetBtn {
            background-color: #f44336;
            color: white;
        }
        #testSpeechBtn {
            background-color: #2196F3;
            color: white;
        }
        #timer {
            font-size: 60px;
            font-weight: bold;
            color: #333;
        }
        #modeToggle, #bufferToggle, #lanesToggle, #voiceToggle, #passToggle {
            font-size: 16px;
            margin: 10px;
        }
        select {
            font-size: 16px;
            padding: 5px;
        }
        #counts {
            font-size: 20px;
            margin: 20px 0;
        }
        #stats {
            margin-top: 50px;
            font-size: 16px;
            text-align: center;
        }
    </style>
</head>
<body>
    <div id="status">Foosball Timer</div>
    <div id="timer">Press Start</div>
    <div id="counts">Made: 0 | Miss: 0</div>
    <label id="modeToggle">
        <input type="checkbox" id="passModeCheckbox"> Enable Pass Timer Mode
    </label>
    <label id="passToggle" style="display: none;">
        Pass Options (Select at least 1):
        <select id="passSelect" multiple size="4">
            <option value="wall" selected>Wall</option>
            <option value="lane" selected>Lane</option>
            <option value="middle" selected>Middle</option>
            <option value="shoot" selected>Shoot</option>
        </select>
    </label>
    <label id="lanesToggle">
        Shot Lanes (Select at least 1):
        <select id="shotLanesSelect" multiple size="5">
            <option value="1" selected>1</option>
            <option value="2" selected>2</option>
            <option value="3" selected>3</option>
            <option value="4" selected>4</option>
            <option value="5" selected>5</option>
        </select>
    </label>
    <label id="bufferToggle">
        Buffer Time (seconds):
        <select id="bufferSelect">
            <option value="1">1</option>
            <option value="2">2</option>
            <option value="3">3</option>
            <option value="4">4</option>
            <option value="5" selected>5</option>
            <option value="6">6</option>
            <option value="7">7</option>
            <option value="8">8</option>
            <option value="9">9</option>
            <option value="10">10</option>
        </select>
    </label>
    <label id="voiceToggle">
        English Voice:
        <select id="voiceSelect">
            <!-- Voices will be populated dynamically -->
        </select>
    </label>
    <button id="startBtn">Start</button>
    <button id="resetBtn" disabled>Reset</button>
    <button id="testSpeechBtn">Test Speech</button>

    <div id="stats">
        <h3>Statistics</h3>
        <p>Pass Makes: 0 | Pass Misses: 0 | Pass Accuracy: 0%</p>
        <p>Shot Makes: 0 | Shot Misses: 0 | Shot Accuracy: 0%</p>
    </div>

    <script>
        const allShotNumbers = ['1', '2', '3', '4', '5'];
        const allPassOptions = ['wall', 'lane', 'middle', 'shoot'];
        let pendingTimers = []; // Array to hold all interval/timeout IDs
        let isRunning = false;
        let wakeLock = null; // For Screen Wake Lock
        let passMakes = 0;
        let passMisses = 0;
        let shotMakes = 0;
        let shotMisses = 0;
        let currentPhase = null; // 'pass' or 'shot' to track current timer
        const maxShotCountdown = 15; // Max time for shot visual countdown
        const minShotDelay = 5; // Min seconds to wait before possible shot call
        const maxPassCountdown = 10; // Max time for pass visual countdown
        const minPassDelay = 4; // Min seconds for pass call
        const statusEl = document.getElementById('status');
        const timerEl = document.getElementById('timer');
        const countsEl = document.getElementById('counts');
        const statsEl = document.getElementById('stats');
        const startBtn = document.getElementById('startBtn');
        const resetBtn = document.getElementById('resetBtn');
        const testSpeechBtn = document.getElementById('testSpeechBtn');
        const passModeCheckbox = document.getElementById('passModeCheckbox');
        const passSelect = document.getElementById('passSelect');
        const shotLanesSelect = document.getElementById('shotLanesSelect');
        const bufferSelect = document.getElementById('bufferSelect');
        const voiceSelect = document.getElementById('voiceSelect');
        const passToggle = document.getElementById('passToggle');

        // Check if speech is supported
        if (!('speechSynthesis' in window)) {
            alert('Your browser does not support text-to-speech. Try Chrome or another browser.');
        }

        // Show/hide pass options and enforce at least one selection
        passModeCheckbox.addEventListener('change', () => {
            passToggle.style.display = passModeCheckbox.checked ? 'block' : 'none';
            if (passModeCheckbox.checked) {
                loadVoices(); // Re-load and set default voice
                validatePassOptions();
            }
        });

        function validatePassOptions() {
            const selectedOptions = Array.from(passSelect.selectedOptions).map(option => option.value);
            if (selectedOptions.length === 0) {
                alert('Please select at least one pass option.');
                passSelect.options[0].selected = true; // Default to Wall
            }
        }

        function validateShotLanes() {
            const selectedLanes = Array.from(shotLanesSelect.selectedOptions).map(option => option.value);
            if (selectedLanes.length === 0) {
                alert('Please select at least one shot lane.');
                shotLanesSelect.options[0].selected = true; // Default to 1
            }
        }

        // Enforce at least one option for pass and shot lanes
        passSelect.addEventListener('change', validatePassOptions);
        shotLanesSelect.addEventListener('change', validateShotLanes);

        // Load and populate English voices
        let voices = [];
        function loadVoices() {
            voices = speechSynthesis.getVoices().filter(voice => voice.lang.startsWith('en-'));
            voiceSelect.innerHTML = ''; // Clear options
            if (voices.length === 0) {
                const option = document.createElement('option');
                option.textContent = 'No English voices available';
                voiceSelect.appendChild(option);
                console.log('No English voices available');
            } else {
                voices.forEach((voice, index) => {
                    const option = document.createElement('option');
                    option.value = index;
                    option.textContent = `${voice.name} (${voice.lang})`;
                    voiceSelect.appendChild(option);
                });
                // Default to Samantha (en-US) if available, else first en-US, else first
                const samanthaIndex = voices.findIndex(voice => voice.name === 'Samantha' && voice.lang === 'en-US');
                const defaultIndex = samanthaIndex !== -1 ? samanthaIndex : voices.findIndex(voice => voice.lang === 'en-US');
                voiceSelect.value = defaultIndex !== -1 ? defaultIndex : 0;
                console.log('Voices loaded:', voices.map(v => `${v.name} (${v.lang})`));
            }
        }

        speechSynthesis.onvoiceschanged = () => {
            loadVoices();
        };
        loadVoices(); // Initial load

        function speak(text) {
            if ('speechSynthesis' in window) {
                // Pause recognition if active
                let wasListening = false;
                if (recognition && !recognition.stopped) {
                    wasListening = true;
                    try {
                        recognition.stop();
                    } catch (e) {
                        console.log('Error stopping recognition:', e);
                    }
                }

                speechSynthesis.cancel(); // Cancel previous
                const utterance = new SpeechSynthesisUtterance(text);
                utterance.volume = 1;
                utterance.rate = 1;
                utterance.pitch = 1;
                // Use selected voice
                const selectedIndex = parseInt(voiceSelect.value, 10);
                if (!isNaN(selectedIndex) && voices[selectedIndex]) {
                    utterance.voice = voices[selectedIndex];
                    console.log(`Speaking "${text}" with voice: ${voices[selectedIndex].name}`);
                } else {
                    console.log(`No valid voice selected for "${text}", using default`);
                }
                utterance.onerror = (e) => {
                    console.error('Speech synthesis error:', e);
                    // Attempt to resume recognition on error
                    if (wasListening && recognition && !recognition.stopped) {
                        try {
                            recognition.start();
                        } catch (e) {
                            console.log('Restart recognition error after speech error:', e);
                        }
                    }
                };
                utterance.onend = () => {
                    console.log(`Finished speaking "${text}"`);
                    if (wasListening && recognition && !recognition.stopped) {
                        try {
                            recognition.start();
                        } catch (e) {
                            console.log('Restart recognition error after speak:', e);
                        }
                    }
                };
                try {
                    speechSynthesis.speak(utterance);
                } catch (e) {
                    console.error('Error initiating speech:', e);
                }
            } else {
                console.log('Speech synthesis not supported');
            }
        }

        // Test speech button
        testSpeechBtn.addEventListener('click', () => {
            speak('test');
        });

        // Handle visibility for resuming speech and wake lock
        document.addEventListener('visibilitychange', async () => {
            if (!document.hidden && 'speechSynthesis' in window) {
                speechSynthesis.resume();
                console.log('Speech synthesis resumed due to visibility change');
            }
            if (!document.hidden && isRunning && 'wakeLock' in navigator) {
                try {
                    wakeLock = await navigator.wakeLock.request('screen');
                    console.log('Wake lock re-acquired');
                } catch (e) {
                    console.log('Wake lock request error:', e);
                }
            }
        });

        async function requestWakeLock() {
            if ('wakeLock' in navigator) {
                try {
                    wakeLock = await navigator.wakeLock.request('screen');
                    console.log('Wake lock acquired');
                } catch (e) {
                    console.log('Wake lock request error:', e);
                }
            }
        }

        function releaseWakeLock() {
            if (wakeLock) {
                wakeLock.release().then(() => {
                    wakeLock = null;
                    console.log('Wake lock released');
                }).catch(e => {
                    console.log('Wake lock release error:', e);
                });
            }
        }

        function startCycle() {
            currentPhase = passModeCheckbox.checked ? 'pass' : 'shot';
            if (passModeCheckbox.checked) {
                startPass();
            } else {
                startShot();
            }
        }

        function startPass() {
            statusEl.textContent = 'Pass Set!';
            speak('set');

            // Choose random time between 4 and 10 seconds for the pass call
            const passDelay = Math.floor(Math.random() * (maxPassCountdown - minPassDelay + 1)) + minPassDelay;

            // Start visual 10s countdown
            let remainingSeconds = maxPassCountdown;
            timerEl.textContent = remainingSeconds;

            const countdownInterval = setInterval(() => {
                remainingSeconds -= 1;
                timerEl.textContent = remainingSeconds;
                if (remainingSeconds < 0) {
                    clearInterval(countdownInterval);
                    pendingTimers = pendingTimers.filter(id => id !== countdownInterval);
                }
            }, 1000);
            pendingTimers.push(countdownInterval);

            // Set timeout for the random pass call
            const passTimeout = setTimeout(() => {
                clearInterval(countdownInterval);
                pendingTimers = pendingTimers.filter(id => id !== countdownInterval);
                pendingTimers = pendingTimers.filter(id => id !== passTimeout);
                // Choose random option from selected passes
                const selectedPassOptions = Array.from(passSelect.selectedOptions).map(option => option.value);
                const randomIndex = Math.floor(Math.random() * selectedPassOptions.length);
                const passCall = selectedPassOptions[randomIndex];
                statusEl.textContent = `Pass: ${passCall}!`;
                speak(passCall);
                // If pass is "shoot", skip to buffer; otherwise, go to shot after 1s
                if (passCall === 'shoot') {
                    // Wait 1 second then start buffer if still running
                    const delayToBuffer = setTimeout(() => {
                        pendingTimers = pendingTimers.filter(id => id !== delayToBuffer);
                        if (isRunning) {
                            startBuffer();
                        }
                    }, 1000);
                    pendingTimers.push(delayToBuffer);
                } else {
                    // Wait 1 second then start shot if still running
                    const delayToShot = setTimeout(() => {
                        pendingTimers = pendingTimers.filter(id => id !== delayToShot);
                        if (isRunning) {
                            startShot();
                        }
                    }, 1000);
                    pendingTimers.push(delayToShot);
                }
            }, passDelay * 1000);
            pendingTimers.push(passTimeout);
        }

        function startShot() {
            currentPhase = 'shot';
            statusEl.textContent = 'Shot Set!';
            speak('set');

            // Choose random time between 5 and 15 seconds for the shot
            const shotDelay = Math.floor(Math.random() * (maxShotCountdown - minShotDelay + 1)) + minShotDelay;

            // Start visual 15s countdown
            let remainingSeconds = maxShotCountdown;
            timerEl.textContent = remainingSeconds;

            const countdownInterval = setInterval(() => {
                remainingSeconds -= 1;
                timerEl.textContent = remainingSeconds;
                if (remainingSeconds < 0) {
                    clearInterval(countdownInterval);
                    pendingTimers = pendingTimers.filter(id => id !== countdownInterval);
                }
            }, 1000);
            pendingTimers.push(countdownInterval);

            // Set timeout for the random shot
            const shotTimeout = setTimeout(() => {
                clearInterval(countdownInterval);
                pendingTimers = pendingTimers.filter(id => id !== countdownInterval);
                pendingTimers = pendingTimers.filter(id => id !== shotTimeout);
                // Choose random number from selected lanes
                const selectedLanes = Array.from(shotLanesSelect.selectedOptions).map(option => option.value);
                const randomIndex = Math.floor(Math.random() * selectedLanes.length);
                const shot = selectedLanes[randomIndex];
                statusEl.textContent = `Shoot ${shot}!`;
                speak(shot);
                // Start buffer if still running
                if (isRunning) {
                    startBuffer();
                }
            }, shotDelay * 1000);
            pendingTimers.push(shotTimeout);
        }

        function startBuffer() {
            currentPhase = 'buffer';
            const bufferTime = parseInt(bufferSelect.value, 10); // Get user-selected buffer time
            let bufferSeconds = bufferTime;
            statusEl.textContent = 'Buffer';
            timerEl.textContent = bufferSeconds;

            const bufferInterval = setInterval(() => {
                bufferSeconds -= 1;
                timerEl.textContent = bufferSeconds;
                if (bufferSeconds <= 0) {
                    clearInterval(bufferInterval);
                    pendingTimers = pendingTimers.filter(id => id !== bufferInterval);
                    if (isRunning) {
                        startCycle(); // Loop back, checking mode
                    }
                }
            }, 1000);
            pendingTimers.push(bufferInterval);
        }

        function handleMakeMiss(transcript) {
            if (transcript === 'make') {
                if (currentPhase === 'pass') {
                    passMakes++;
                } else if (currentPhase === 'shot') {
                    shotMakes++;
                }
            } else if (transcript === 'miss') {
                if (currentPhase === 'pass') {
                    passMisses++;
                    resetCycle();
                    startCycle(); // Restart immediately
                    return;
                } else if (currentPhase === 'shot') {
                    shotMisses++;
                }
            }
            updateCounts();
        }

        function updateCounts() {
            const totalMakes = passMakes + shotMakes;
            const totalMisses = passMisses + shotMisses;
            countsEl.textContent = `Made: ${totalMakes} | Miss: ${totalMisses}`;

            const passAccuracy = passMakes + passMisses > 0 ? ((passMakes / (passMakes + passMisses)) * 100).toFixed(2) : 0;
            const shotAccuracy = shotMakes + shotMisses > 0 ? ((shotMakes / (shotMakes + shotMisses)) * 100).toFixed(2) : 0;

            statsEl.innerHTML = `
                <h3>Statistics</h3>
                <p>Pass Makes: ${passMakes} | Pass Misses: ${passMisses} | Pass Accuracy: ${passAccuracy}%</p>
                <p>Shot Makes: ${shotMakes} | Shot Misses: ${shotMisses} | Shot Accuracy: ${shotAccuracy}%</p>
            `;
        }

        function resetCycle() {
            isRunning = false;
            // Clear all pending timers immediately
            while (pendingTimers.length > 0) {
                const id = pendingTimers.pop();
                clearInterval(id);
                clearTimeout(id);
            }
            speechSynthesis.cancel(); // Stop any ongoing speech
            releaseWakeLock(); // Release screen wake lock
            currentPhase = null;
            startBtn.disabled = false;
            resetBtn.disabled = true;
            statusEl.textContent = 'Foosball Timer';
            timerEl.textContent = 'Press Start';
        }

        // Voice command setup
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        let recognition;
        if (SpeechRecognition) {
            recognition = new SpeechRecognition();
            recognition.continuous = true;
            recognition.interimResults = false;
            recognition.lang = 'en-US';

            recognition.onresult = (event) => {
                const transcript = event.results[event.results.length - 1][0].transcript.trim().toLowerCase();
                console.log('Heard voice command:', transcript);
                if (transcript === 'start' && !isRunning) {
                    startBtn.click(); // Simulate start
                } else if (transcript === 'reset') {
                    resetBtn.click(); // Simulate reset
                } else if (transcript === 'make' || transcript === 'miss') {
                    handleMakeMiss(transcript);
                }
            };

            recognition.onend = () => {
                // Restart for continuous listening
                if (!recognition.stopped) {
                    try {
                        recognition.start();
                        console.log('Speech recognition restarted');
                    } catch (e) {
                        console.log('Voice recognition restart error:', e);
                    }
                }
            };

            recognition.onerror = (event) => {
                console.log('Voice recognition error:', event.error);
                if (event.error === 'not-allowed' || event.error === 'permission-denied') {
                    alert('Microphone permission denied. Voice commands disabled.');
                    recognition.stopped = true;
                }
            };

            // Start listening (may prompt for permission)
            try {
                recognition.start();
                console.log('Speech recognition started');
            } catch (e) {
                console.log('Initial voice recognition start error:', e);
            }
        } else {
            console.log('SpeechRecognition not supported in this browser.');
        }

        startBtn.addEventListener('click', async () => {
            isRunning = true;
            pendingTimers = []; // Reset on new start
            startBtn.disabled = true;
            resetBtn.disabled = false;
            await requestWakeLock(); // Request screen wake lock
            startCycle();
        });
        resetBtn.addEventListener('click', resetCycle);
        testSpeechBtn.addEventListener('click', () => {
            speak('test');
        });
        updateCounts(); // Initial update
    </script>
</body>
</html>
