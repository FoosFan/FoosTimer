<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Foosball Timer</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            height: auto; /* Allow scrolling */
            margin: 0;
            background-color: #f0f0f0;
            padding: 20px;
        }
        #status {
            font-size: 24px;
            margin-bottom: 20px;
        }
        button {
            font-size: 18px;
            padding: 10px 20px;
            margin: 10px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
        #startBtn {
            background-color: #4CAF50;
            color: white;
        }
        #resetBtn {
            background-color: #f44336;
            color: white;
        }
        #testSpeechBtn {
            background-color: #2196F3;
            color: white;
        }
        #timer {
            font-size: 60px;
            font-weight: bold;
            color: #333;
        }
        #modeToggle, #bufferToggle, #lanesToggle, #voiceToggle, #passToggle {
            font-size: 16px;
            margin: 10px;
        }
        select {
            font-size: 16px;
            padding: 5px;
        }
        #counts {
            font-size: 20px;
            margin: 20px 0;
        }
        #stats {
            margin-top: 50px;
            font-size: 16px;
            text-align: center;
            width: 100%;
        }
        .stats-section {
            margin-bottom: 20px;
        }
    </style>
</head>
<body>
    <div id="status">Foosball Timer</div>
    <div id="timer">Press Start</div>
    <div id="counts">Made: 0 | Miss: 0</div>
    <label id="modeToggle">
        <input type="checkbox" id="passModeCheckbox"> Enable Pass Timer Mode
    </label>
    <label id="passToggle" style="display: none;">
        Pass Options (Select at least 1):
        <select id="passSelect" multiple size="4">
            <option value="wall" selected>Wall</option>
            <option value="lane" selected>Lane</option>
            <option value="middle" selected>Middle</option>
            <option value="shoot" selected>Shoot</option>
        </select>
    </label>
    <label id="lanesToggle">
        Shot Lanes (Select at least 1):
        <select id="shotLanesSelect" multiple size="5">
            <option value="1" selected>1</option>
            <option value="2" selected>2</option>
            <option value="3" selected>3</option>
            <option value="4" selected>4</option>
            <option value="5" selected>5</option>
        </select>
    </label>
    <label id="bufferToggle">
        Buffer Time (seconds):
        <select id="bufferSelect">
            <option value="1">1</option>
            <option value="2">2</option>
            <option value="3">3</option>
            <option value="4">4</option>
            <option value="5" selected>5</option>
            <option value="6">6</option>
            <option value="7">7</option>
            <option value="8">8</option>
            <option value="9">9</option>
            <option value="10">10</option>
        </select>
    </label>
    <label id="voiceToggle">
        English Voice:
        <select id="voiceSelect">
            <!-- Voices will be populated dynamically -->
        </select>
    </label>
    <button id="startBtn">Start</button>
    <button id="resetBtn" disabled>Reset</button>
    <button id="testSpeechBtn">Test Speech</button>

    <div id="stats">
        <h3>Statistics</h3>
        <p>Total Practice Time: 0 hours 0 minutes</p>
        <div class="stats-section">
            <h4>Pass Statistics</h4>
            <p id="passStats">No pass stats yet</p>
        </div>
        <div class="stats-section">
            <h4>Shot Statistics</h4>
            <p id="shotStats">No shot stats yet</p>
        </div>
    </div>

    <script>
        const allShotNumbers = ['1', '2', '3', '4', '5'];
        const allPassOptions = ['wall', 'lane', 'middle', 'shoot'];
        let pendingTimers = []; // Array to hold all interval/timeout IDs
        let isRunning = false;
        let wakeLock = null; // For Screen Wake Lock
        let passStats = {}; // {date: {wall: {makes: 0, misses: 0}, ...}}
        let shotStats = {}; // {date: {1: {makes: 0, misses: 0}, ...}}
        let practiceTime = {}; // {date: totalSeconds}
        let practiceTimerInterval = null;
        let practiceStartTime = null;
        let currentPhase = null; // 'pass' or 'shot'
        let lastPassCall = null; // To track if pass was 'shoot'
        let lastCall = null; // To track the last pass or shot call for stats
        let passMakes = 0;
        let passMisses = 0;
        let shotMakes = 0;
        let shotMisses = 0;
        const maxShotCountdown = 15; // Max time for shot visual countdown
        const minShotDelay = 5; // Min seconds to wait before possible shot call
        const maxPassCountdown = 10; // Max time for pass visual countdown
        const minPassDelay = 4; // Min seconds for pass call
        const statusEl = document.getElementById('status');
        const timerEl = document.getElementById('timer');
        const countsEl = document.getElementById('counts');
        const passStatsEl = document.getElementById('passStats');
        const shotStatsEl = document.getElementById('shotStats');
        const totalPracticeEl = document.querySelector('#stats p:first-child');
        const startBtn = document.getElementById('startBtn');
        const resetBtn = document.getElementById('resetBtn');
        const testSpeechBtn = document.getElementById('testSpeechBtn');
        const passModeCheckbox = document.getElementById('passModeCheckbox');
        const passSelect = document.getElementById('passSelect');
        const shotLanesSelect = document.getElementById('shotLanesSelect');
        const bufferSelect = document.getElementById('bufferSelect');
        const voiceSelect = document.getElementById('voiceSelect');
        const passToggle = document.getElementById('passToggle');

        // Load saved settings and stats from localStorage
        function loadSettings() {
            const savedPassMode = localStorage.getItem('passMode');
            if (savedPassMode !== null) {
                passModeCheckbox.checked = JSON.parse(savedPassMode);
                passToggle.style.display = passModeCheckbox.checked ? 'block' : 'none';
            }

            const savedPassOptions = localStorage.getItem('passOptions');
            if (savedPassOptions) {
                const selected = JSON.parse(savedPassOptions);
                Array.from(passSelect.options).forEach(option => {
                    option.selected = selected.includes(option.value);
                });
            }

            const savedShotLanes = localStorage.getItem('shotLanes');
            if (savedShotLanes) {
                const selected = JSON.parse(savedShotLanes);
                Array.from(shotLanesSelect.options).forEach(option => {
                    option.selected = selected.includes(option.value);
                });
            }

            const savedBufferTime = localStorage.getItem('bufferTime');
            if (savedBufferTime) {
                bufferSelect.value = savedBufferTime;
            }

            const savedVoice = localStorage.getItem('voice');
            if (savedVoice) {
                voiceSelect.value = savedVoice;
            }

            const savedPassStats = localStorage.getItem('passStats');
            if (savedPassStats) {
                passStats = JSON.parse(savedPassStats);
            }

            const savedShotStats = localStorage.getItem('shotStats');
            if (savedShotStats) {
                shotStats = JSON.parse(savedShotStats);
            }

            const savedPracticeTime = localStorage.getItem('practiceTime');
            if (savedPracticeTime) {
                practiceTime = JSON.parse(savedPracticeTime);
            }

            calculateTotals();
            updateCounts();
        }

        // Calculate totals from stats
        function calculateTotals() {
            passMakes = 0;
            passMisses = 0;
            shotMakes = 0;
            shotMisses = 0;
            for (let date in passStats) {
                for (let option in passStats[date]) {
                    passMakes += passStats[date][option].makes;
                    passMisses += passStats[date][option].misses;
                }
            }
            for (let date in shotStats) {
                for (let lane in shotStats[date]) {
                    shotMakes += shotStats[date][lane].makes;
                    shotMisses += shotStats[date][lane].misses;
                }
            }
        }

        // Save settings to localStorage
        function saveSettings() {
            localStorage.setItem('passMode', JSON.stringify(passModeCheckbox.checked));
            const selectedPass = Array.from(passSelect.selectedOptions).map(option => option.value);
            localStorage.setItem('passOptions', JSON.stringify(selectedPass));
            const selectedLanes = Array.from(shotLanesSelect.selectedOptions).map(option => option.value);
            localStorage.setItem('shotLanes', JSON.stringify(selectedLanes));
            localStorage.setItem('bufferTime', bufferSelect.value);
            localStorage.setItem('voice', voiceSelect.value);
        }

        // Save stats and practice time to localStorage
        function saveData() {
            localStorage.setItem('passStats', JSON.stringify(passStats));
            localStorage.setItem('shotStats', JSON.stringify(shotStats));
            localStorage.setItem('practiceTime', JSON.stringify(practiceTime));
        }

        // Get today's date key
        function getTodayKey() {
            const today = new Date();
            return today.toISOString().split('T')[0]; // YYYY-MM-DD
        }

        // Initialize daily stats if not exist
        function initDailyStats() {
            const today = getTodayKey();
            if (!passStats[today]) {
                passStats[today] = {};
                allPassOptions.forEach(option => {
                    passStats[today][option] = {makes: 0, misses: 0};
                });
            }
            if (!shotStats[today]) {
                shotStats[today] = {};
                allShotNumbers.forEach(lane => {
                    shotStats[today][lane] = {makes: 0, misses: 0};
                });
            }
            if (!practiceTime[today]) {
                practiceTime[today] = 0;
            }
            saveData();
        }

        // Start practice timer
        function startPracticeTimer() {
            if (!practiceStartTime) {
                practiceStartTime = Date.now();
            }
            if (!practiceTimerInterval) {
                practiceTimerInterval = setInterval(() => {
                    const elapsed = Math.floor((Date.now() - practiceStartTime) / 1000);
                    practiceTime[getTodayKey()] += elapsed;
                    practiceStartTime = Date.now();
                    saveData();
                    updateCounts();
                }, 1000); // Update every second
            }
        }

        // Stop practice timer
        function stopPracticeTimer() {
            if (practiceTimerInterval) {
                clearInterval(practiceTimerInterval);
                practiceTimerInterval = null;
            }
            if (practiceStartTime) {
                const elapsed = Math.floor((Date.now() - practiceStartTime) / 1000);
                practiceTime[getTodayKey()] += elapsed;
                practiceStartTime = null;
                saveData();
                updateCounts();
            }
        }

        // Check if speech is supported
        if (!('speechSynthesis' in window)) {
            alert('Your browser does not support text-to-speech. Try Chrome or another browser.');
        }

        // Show/hide pass options and enforce at least one selection
        passModeCheckbox.addEventListener('change', () => {
            passToggle.style.display = passModeCheckbox.checked ? 'block' : 'none';
            if (passModeCheckbox.checked) {
                loadVoices(); // Re-load and set default voice
                validatePassOptions();
            }
            saveSettings();
        });

        function validatePassOptions() {
            const selectedOptions = Array.from(passSelect.selectedOptions).map(option => option.value);
            if (selectedOptions.length === 0) {
                alert('Please select at least one pass option.');
                passSelect.options[0].selected = true; // Default to Wall
            }
        }

        function validateShotLanes() {
            const selectedLanes = Array.from(shotLanesSelect.selectedOptions).map(option => option.value);
            if (selectedLanes.length === 0) {
                alert('Please select at least one shot lane.');
                shotLanesSelect.options[0].selected = true; // Default to 1
            }
        }

        // Enforce at least one option for pass and shot lanes
        passSelect.addEventListener('change', () => {
            validatePassOptions();
            saveSettings();
        });
        shotLanesSelect.addEventListener('change', () => {
            validateShotLanes();
            saveSettings();
        });
        bufferSelect.addEventListener('change', saveSettings);
        voiceSelect.addEventListener('change', saveSettings);

        // Load and populate English voices
        let voices = [];
        function loadVoices() {
            voices = speechSynthesis.getVoices().filter(voice => voice.lang.startsWith('en-'));
            voiceSelect.innerHTML = ''; // Clear options
            if (voices.length === 0) {
                const option = document.createElement('option');
                option.textContent = 'No English voices available';
                voiceSelect.appendChild(option);
                console.log('No English voices available');
            } else {
                voices.forEach((voice, index) => {
                    const option = document.createElement('option');
                    option.value = index;
                    option.textContent = `${voice.name} (${voice.lang})`;
                    voiceSelect.appendChild(option);
                });
                // Default to Samantha (en-US) if available, else first en-US, else first
                const samanthaIndex = voices.findIndex(voice => voice.name === 'Samantha' && voice.lang === 'en-US');
                const defaultIndex = samanthaIndex !== -1 ? samanthaIndex : voices.findIndex(voice => voice.lang === 'en-US');
                voiceSelect.value = defaultIndex !== -1 ? defaultIndex : 0;
                console.log('Voices loaded:', voices.map(v => `${v.name} (${v.lang})`));
            }
        }

        speechSynthesis.onvoiceschanged = () => {
            loadVoices();
        };
        loadVoices(); // Initial load

        function speak(text) {
            if ('speechSynthesis' in window) {
                // Pause recognition if active
                let wasListening = false;
                if (recognition && !recognition.stopped) {
                    wasListening = true;
                    try {
                        recognition.stop();
                    } catch (e) {
                        console.log('Error stopping recognition:', e);
                    }
                }

                speechSynthesis.cancel(); // Cancel previous
                const utterance = new SpeechSynthesisUtterance(text);
                utterance.volume = 1;
                utterance.rate = 1;
                utterance.pitch = 1;
                // Use selected voice
                const selectedIndex = parseInt(voiceSelect.value, 10);
                if (!isNaN(selectedIndex) && voices[selectedIndex]) {
                    utterance.voice = voices[selectedIndex];
                    console.log(`Speaking "${text}" with voice: ${voices[selectedIndex].name}`);
                } else {
                    console.log(`No valid voice selected for "${text}", using default`);
                }
                utterance.onerror = (e) => {
                    console.error('Speech synthesis error:', e);
                    // Attempt to resume recognition on error
                    if (wasListening && recognition && !recognition.stopped) {
                        try {
                            recognition.start();
                        } catch (e) {
                            console.log('Restart recognition error after speech error:', e);
                        }
                    }
                };
                utterance.onend = () => {
                    console.log(`Finished speaking "${text}"`);
                    if (wasListening && recognition && !recognition.stopped) {
                        try {
                            recognition.start();
                        } catch (e) {
                            console.log('Restart recognition error after speak:', e);
                        }
                    }
                };
                try {
                    speechSynthesis.speak(utterance);
                } catch (e) {
                    console.error('Error initiating speech:', e);
                }
            } else {
                console.log('Speech synthesis not supported');
            }
        }

        // Test speech button
        testSpeechBtn.addEventListener('click', () => {
            speak('test');
        });

        // Handle visibility for resuming speech and wake lock
        document.addEventListener('visibilitychange', async () => {
            if (!document.hidden && 'speechSynthesis' in window) {
                speechSynthesis.resume();
                console.log('Speech synthesis resumed due to visibility change');
            }
            if (!document.hidden && isRunning && 'wakeLock' in navigator) {
                try {
                    wakeLock = await navigator.wakeLock.request('screen');
                    console.log('Wake lock re-acquired');
                } catch (e) {
                    console.log('Wake lock request error:', e);
                }
            }
            if (document.hidden && isRunning) {
                stopPracticeTimer(); // Save time on background
            } else if (!document.hidden && isRunning) {
                startPracticeTimer(); // Resume timer on foreground
            }
        });

        // Handle unload for saving practice time
        window.addEventListener('unload', () => {
            stopPracticeTimer();
        });

        async function requestWakeLock() {
            if ('wakeLock' in navigator) {
                try {
                    wakeLock = await navigator.wakeLock.request('screen');
                    console.log('Wake lock acquired');
                } catch (e) {
                    console.log('Wake lock request error:', e);
                }
            }
        }

        function releaseWakeLock() {
            if (wakeLock) {
                wakeLock.release().then(() => {
                    wakeLock = null;
                    console.log('Wake lock released');
                }).catch(e => {
                    console.log('Wake lock release error:', e);
                });
            }
        }

        function startCycle() {
            lastPassCall = null;
            lastCall = null;
            currentPhase = passModeCheckbox.checked ? 'pass' : 'shot';
            if (passModeCheckbox.checked) {
                startPass();
            } else {
                startShot();
            }
        }

        function startPass() {
            statusEl.textContent = 'Pass Set!';
            speak('set');

            // Choose random time between 4 and 10 seconds for the pass call
            const passDelay = Math.floor(Math.random() * (maxPassCountdown - minPassDelay + 1)) + minPassDelay;

            // Start visual 10s countdown
            let remainingSeconds = maxPassCountdown;
            timerEl.textContent = remainingSeconds;

            const countdownInterval = setInterval(() => {
                remainingSeconds -= 1;
                timerEl.textContent = remainingSeconds;
                if (remainingSeconds < 0) {
                    clearInterval(countdownInterval);
                    pendingTimers = pendingTimers.filter(id => id !== countdownInterval);
                }
            }, 1000);
            pendingTimers.push(countdownInterval);

            // Set timeout for the random pass call
            const passTimeout = setTimeout(() => {
                clearInterval(countdownInterval);
                pendingTimers = pendingTimers.filter(id => id !== countdownInterval);
                pendingTimers = pendingTimers.filter(id => id !== passTimeout);
                // Choose random option from selected passes
                const selectedPassOptions = Array.from(passSelect.selectedOptions).map(option => option.value);
                const randomIndex = Math.floor(Math.random() * selectedPassOptions.length);
                const passCall = selectedPassOptions[randomIndex];
                lastPassCall = passCall;
                lastCall = passCall; // For stats
                statusEl.textContent = `Pass: ${passCall}!`;
                speak(passCall);
                // If pass is "shoot", treat as pass for stats, but skip shot
                if (passCall === 'shoot') {
                    // Wait 1 second then start buffer if still running
                    const delayToBuffer = setTimeout(() => {
                        pendingTimers = pendingTimers.filter(id => id !== delayToBuffer);
                        if (isRunning) {
                            startBuffer();
                        }
                    }, 1000);
                    pendingTimers.push(delayToBuffer);
                } else {
                    // Wait 1 second then start shot if still running
                    const delayToShot = setTimeout(() => {
                        pendingTimers = pendingTimers.filter(id => id !== delayToShot);
                        if (isRunning) {
                            startShot();
                        }
                    }, 1000);
                    pendingTimers.push(delayToShot);
                }
            }, passDelay * 1000);
            pendingTimers.push(passTimeout);
        }

        function startShot() {
            lastPassCall = null; // Reset for normal shot
            statusEl.textContent = 'Shot Set!';
            speak('set');

            // Choose random time between 5 and 15 seconds for the shot
            const shotDelay = Math.floor(Math.random() * (maxShotCountdown - minShotDelay + 1)) + minShotDelay;

            // Start visual 15s countdown
            let remainingSeconds = maxShotCountdown;
            timerEl.textContent = remainingSeconds;

            const countdownInterval = setInterval(() => {
                remainingSeconds -= 1;
                timerEl.textContent = remainingSeconds;
                if (remainingSeconds < 0) {
                    clearInterval(countdownInterval);
                    pendingTimers = pendingTimers.filter(id => id !== countdownInterval);
                }
            }, 1000);
            pendingTimers.push(countdownInterval);

            // Set timeout for the random shot
            const shotTimeout = setTimeout(() => {
                clearInterval(countdownInterval);
                pendingTimers = pendingTimers.filter(id => id !== countdownInterval);
                pendingTimers = pendingTimers.filter(id => id !== shotTimeout);
                // Choose random number from selected lanes
                const selectedLanes = Array.from(shotLanesSelect.selectedOptions).map(option => option.value);
                const randomIndex = Math.floor(Math.random() * selectedLanes.length);
                const shot = selectedLanes[randomIndex];
                lastCall = shot; // For stats
                statusEl.textContent = `Shoot ${shot}!`;
                speak(shot);
                // Start buffer if still running
                if (isRunning) {
                    startBuffer();
                }
            }, shotDelay * 1000);
            pendingTimers.push(shotTimeout);
        }

        function startBuffer() {
            const bufferTime = parseInt(bufferSelect.value, 10); // Get user-selected buffer time
            let bufferSeconds = bufferTime;
            statusEl.textContent = 'Buffer';
            timerEl.textContent = bufferSeconds;

            const bufferInterval = setInterval(() => {
                bufferSeconds -= 1;
                timerEl.textContent = bufferSeconds;
                if (bufferSeconds <= 0) {
                    clearInterval(bufferInterval);
                    pendingTimers = pendingTimers.filter(id => id !== bufferInterval);
                    if (isRunning) {
                        startCycle();
                    }
                }
            }, 1000);
            pendingTimers.push(bufferInterval);
        }

        function handleMakeMiss(transcript) {
            if (lastCall && currentPhase) {
                const today = getTodayKey();
                if (lastPassCall) { // Pass phase, including 'shoot'
                    passStats[today][lastCall][transcript === 'make' ? 'makes' : 'misses']++;
                    if (transcript === 'make') {
                        passMakes++;
                    } else {
                        passMisses++;
                        if (lastPassCall !== 'shoot') {
                            resetCycle();
                            startCycle(); // Restart immediately
                            return;
                        }
                    }
                } else { // Normal shot phase
                    shotStats[today][lastCall][transcript === 'make' ? 'makes' : 'misses']++;
                    if (transcript === 'make') {
                        shotMakes++;
                    } else {
                        shotMisses++;
                    }
                }
                saveData();
                updateCounts();
            }
        }

        function updateCounts() {
            const totalMakes = passMakes + shotMakes;
            const totalMisses = passMisses + shotMisses;
            countsEl.textContent = `Made: ${totalMakes} | Miss: ${totalMisses}`;

            const today = getTodayKey();
            let passStatsText = 'Pass Stats:<br>';
            for (let option in passStats[today]) {
                const stats = passStats[today][option];
                const accuracy = stats.makes + stats.misses > 0 ? ((stats.makes / (stats.makes + stats.misses)) * 100).toFixed(2) : 0;
                passStatsText += `${option}: Makes ${stats.makes} | Misses ${stats.misses} | Accuracy ${accuracy}%<br>`;
            }
            passStatsEl.innerHTML = passStatsText;

            let shotStatsText = 'Shot Stats:<br>';
            for (let lane in shotStats[today]) {
                const stats = shotStats[today][lane];
                const accuracy = stats.makes + stats.misses > 0 ? ((stats.makes / (stats.makes + stats.misses)) * 100).toFixed(2) : 0;
                shotStatsText += `Lane ${lane}: Makes ${stats.makes} | Misses ${stats.misses} | Accuracy ${accuracy}%<br>`;
            }
            shotStatsEl.innerHTML = shotStatsText;

            const totalSeconds = practiceTime[today] || 0;
            const hours = Math.floor(totalSeconds / 3600);
            const minutes = Math.floor((totalSeconds % 3600) / 60);
            totalPracticeEl.textContent = `Total Practice Time: ${hours} hours ${minutes} minutes`;
        }

        function resetCycle() {
            stopPracticeTimer();
            isRunning = false;
            // Clear all pending timers immediately
            while (pendingTimers.length > 0) {
                const id = pendingTimers.pop();
                clearInterval(id);
                clearTimeout(id);
            }
            speechSynthesis.cancel(); // Stop any ongoing speech
            releaseWakeLock(); // Release screen wake lock
            currentPhase = null;
            lastPassCall = null;
            lastCall = null;
            startBtn.disabled = false;
            resetBtn.disabled = true;
            statusEl.textContent = 'Foosball Timer';
            timerEl.textContent = 'Press Start';
        }

        // Voice command setup
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        let recognition;
        if (SpeechRecognition) {
            recognition = new SpeechRecognition();
            recognition.continuous = true;
            recognition.interimResults = false;
            recognition.lang = 'en-US';

            recognition.onresult = (event) => {
                const transcript = event.results[event.results.length - 1][0].transcript.trim().toLowerCase();
                console.log('Heard voice command:', transcript);
                if (transcript === 'start' && !isRunning) {
                    startBtn.click(); // Simulate start
                } else if (transcript === 'reset') {
                    resetBtn.click(); // Simulate reset
                } else if (transcript === 'make' || transcript === 'miss') {
                    handleMakeMiss(transcript);
                }
            };

            recognition.onend = () => {
                // Restart for continuous listening
                if (!recognition.stopped) {
                    try {
                        recognition.start();
                        console.log('Speech recognition restarted');
                    } catch (e) {
                        console.log('Voice recognition restart error:', e);
                    }
                }
            };

            recognition.onerror = (event) => {
                console.log('Voice recognition error:', event.error);
                if (event.error === 'not-allowed' || event.error === 'permission-denied') {
                    alert('Microphone permission denied. Voice commands disabled.');
                    recognition.stopped = true;
                }
            };

            // Start listening (may prompt for permission)
            try {
                recognition.start();
                console.log('Speech recognition started');
            } catch (e) {
                console.log('Initial voice recognition start error:', e);
            }
        } else {
            console.log('SpeechRecognition not supported in this browser.');
        }

        startBtn.addEventListener('click', async () => {
            isRunning = true;
            pendingTimers = []; // Reset on new start
            startBtn.disabled = true;
            resetBtn.disabled = false;
            await requestWakeLock(); // Request screen wake lock
            startPracticeTimer();
            startCycle();
        });
        resetBtn.addEventListener('click', resetCycle);
        testSpeechBtn.addEventListener('click', () => {
            speak('test');
        });

        // Load settings and init stats
        loadSettings();
        initDailyStats();
        updateCounts();
    </script>
</body>
</html>
